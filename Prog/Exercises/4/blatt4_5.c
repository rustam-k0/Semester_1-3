#include <stdio.h>

int main() {
    int Ns[3] = {10000, 100000, 1000000};

    for (int k = 0; k < 3; k++) {
        int N = Ns[k];
        float sf = 0.0f;
        double sd = 0.0;

        for (int i = 1; i <= N; i++) sf += 1.0f / i;
        for (int i = 1; i <= N; i++) sd += 1.0  / i;

        printf("%f %f\n", sf, sd);
    }

    return 0;
}

/*
Главное:
Показать потерю точности при работе с плавающей запятой.

Что проверялось:
1. Суммирование первых n членов гармонического ряда делалось дважды:
   – с типом float (32 бита, ~7 значащих цифр)
   – с типом double (64 бита, ~15–16 значащих цифр)

2. При больших n (10000, 100000, 1000000) стало видно:
   – float теряет мелкие добавки и даёт заметную ошибку
   – double сохраняет точность значительно дольше, результат ближе к эталонным значениям

Вывод:
При суммах из большого числа очень маленьких слагаемых тип float быстро начинает "проглатывать" новые значения, поэтому итог сильно занижен. Double работает точнее, но тоже не идеален. Для численных расчётов большой длины float непригоден.
*/
