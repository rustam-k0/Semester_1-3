#include <stdio.h>

int main(){
  unsigned long long n;
  unsigned long long fact = 1;

  printf("Enter n: ");
  scanf("%llu", &n);

  for (unsigned long long i =1; i<= n; i++){
    fact *=i;
  }

  printf("Factorial = %llu\n", fact);
    // int fits up to 12! (13! overflows)
    // unsigned int fits up to 12!
    // long long fits up to 20!
    // unsigned long long fits up to 20!
    
  
    return 0;

}

/*
ТИПЫ И ФАКТОРИАЛ: ПОЛНОЕ ОБЪЯСНЕНИЕ

1. Сколько бит у типов:
   - int: обычно 32 бита (ANSI C гарантирует >=16, но на всех нормальных платформах — 32)
   - unsigned int: 32 бита
   - long long: 64 бита
   - unsigned long long: 64 бита

   Форматы:
   - 32-бит signed  → диапазон ≈ −2.1e9 … +2.1e9
   - 32-бит unsigned → диапазон ≈ 0 … 4.29e9
   - 64-бит signed → диапазон ≈ −9.22e18 … +9.22e18
   - 64-бит unsigned → диапазон ≈ 0 … 1.84e19

   Максимальное число для n! подбираем так:
   Ищем самое большое n, для которого n! ≤ max_значение_типа.

2. Факториалы нужных чисел:
   10! = 3 628 800  
   11! = 39 916 800  
   12! = 479 001 600  
   13! = 6 227 020 800  
   20! = 2 432 902 008 176 640 000  
   21! = 51 090 942 171 709 440 000  

3. Сравнение factorial vs диапазон типов:

   int (32-бит signed)
   - max =  2 147 483 647
   - 12! =   479 001 600         (влезает)
   - 13! = 6 227 020 800         (ПЕРЕПОЛНЕНИЕ)
   → максимум: 12!

   unsigned int (32-бит unsigned)
   - max = 4 294 967 295
   - 12! = 479 001 600           (влезает)
   - 13! = 6 227 020 800         (ПЕРЕПОЛНЕНИЕ)
   → максимум: 12!

   long long (64-бит signed)
   - max ≈ 9.22e18
   - 20! = 2.43e18               (влезает)
   - 21! = 5.10e19               (ПЕРЕПОЛНЕНИЕ)
   → максимум: 20!

   unsigned long long (64-бит unsigned)
   - max ≈ 1.84e19
   - 20! = 2.43e18               (влезает)
   - 21! = 5.10e19               (ПЕРЕПОЛНЕНИЕ)
   → максимум: 20!

Итог:
- 32-битные типы держат до 12!
- 64-битные — до 20!
Факториал растёт быстрее, чем любые стандартные типы успевают его хранить.
*/
