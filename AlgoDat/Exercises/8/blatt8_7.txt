### Перевод задания 8.7

**Задача 8.7 (Красно-черное дерево — Правый поворот)** 

Следующий код, предназначенный для реализации «правого поворота» в красно-черном дереве (с левосторонними красными связями), содержит ошибку. Эта операция необходима для всех вставок в дерево. Опишите эту ошибку и способ ее исправления.


*Примечание: поле `size` представляет количество узлов в соответствующем поддереве и его можно игнорировать при рассмотрении.* 

**Исходный код с ошибкой:**

```java
private Node rotateRight (Node n) {
    Node t = n;       // <--- ОШИБКА ЗДЕСЬ
    n.left = t.right;
    t.right = n;
    t.color = n.color;
    t.size = n.size;
    n.size = 1 + size(n.left) + size(n.right);
    return t;
}

```



---

### Подробный разбор: Механика и Цвета

Рустам, чтобы понять ошибку, давай разберем, как **должен** работать правый поворот, и что происходит в этом коде на самом деле.

#### 1. Как работает Правый Поворот (Right Rotation)

Представь, что у тебя есть узел **N** (корень поддерева) и его левый ребенок **L** (Left).
Правый поворот — это операция, при которой **L** поднимается вверх и становится новым корнем, а **N** опускается вниз и становится *правым* ребенком узла **L**.

**Схема правильного поворота:**

```text
      N                  L
     / \               /   \
    L   R     ==>     LL    N
   / \                     / \
  LL LR                   LR  R

```

*Заметь:* Поддерево `LR` (правый ребенок `L`) переходит к `N` и становится его левым ребенком.

#### 2. В чем конкретно ошибка кода?

Посмотри на первую строку метода в задании:


`Node t = n;` 

Здесь создается временная переменная `t`, но вместо того, чтобы взять левого ребенка (`n.left`), который должен стать новым корнем, код просто копирует ссылку на сам `n`.
Теперь `t` и `n` указывают на **один и тот же объект**.

Что происходит дальше в строке `n.left = t.right;`?
Так как `t == n`, это равносильно `n.left = n.right;`.
**Результат:** Ты только что перезаписал ссылку на левое поддерево ссылкой на правое. Левая часть дерева (включая тот узел, который мы хотели поднять наверх) просто "отвалилась" и потеряна. Сборщик мусора её уничтожит. Структура дерева разрушена.

**Как должно быть:**
Переменная `t` (временный новый корень) должна указывать на левого ребенка.
`Node t = n.left;`

#### 3. Принцип покраски (Coloring)

Ты спросил про принцип покраски. В красно-черных деревьях (особенно в реализации Sedgewick, LLRB — Left-Leaning Red-Black BST, которая используется у вас в лекциях ) повороты нужны для поддержания инвариантов.

Правый поворот обычно применяется, когда у нас есть **два красных узла подряд** на левой ветке (что запрещено) или мы выравниваем дерево.

**Логика цветов при повороте:**

1. 
**Наследование цвета (`t.color = n.color`):** 
Новый корень поддерева (`t` или `L` на схеме) должен принять цвет старого корня (`n`). Это критически важно, чтобы для "внешнего мира" (узла-родителя выше) количество черных узлов на пути вниз не изменилось. Если `n` был черным, `t` станет черным. Если `n` был красным (часть красной связи выше), `t` станет красным.


2. **Покраска старого корня (`n.color = RED`):**
В коде задания этой строки **нет**, и это тоже часть проблемы, хотя главная ошибка в ссылках. В классической реализации LLRB после правого поворота старый корень (`n`), ставший правым потомком, обычно окрашивается в **КРАСНЫЙ** цвет.
*Почему?* Потому что правый поворот часто делается, чтобы разбить цепочку красных ссылок. Вращение превращает вертикальную пару (или угол) в горизонтальную связь, сохраняя локальную "черную высоту".

---

### Исправленный алгоритм (Решение)

Вот как должен выглядеть рабочий код на Java. Я исправил ошибку инициализации `t` и добавил необходимую перекраску `n`.

```java
private Node rotateRight(Node n) {
    // 1. Инициализируем t как ЛЕВОГО ребенка (это будущий корень)
    // В оригинале было Node t = n; <- ОШИБКА
    Node t = n.left; 
    
    // 2. Перемещаем правое поддерево t (LR) под левое плечо n
    n.left = t.right; 
    
    // 3. Поднимаем t, делая n его правым ребенком
    t.right = n; 
    
    // 4. Управление цветами
    t.color = n.color; // t принимает цвет n, чтобы не нарушить черную высоту
    n.color = RED;     // n становится красным (внутренняя связь)
    
    // 5. Пересчет размеров (раз уж он есть в задании)
    t.size = n.size;
    n.size = 1 + size(n.left) + size(n.right);
    
    return t; // Возвращаем новый корень поддерева
}

```

### Следующий шаг

Хочешь, я разберу задачу 8.6 (вставка в дерево с визуализацией), чтобы закрепить понимание того, когда именно применяются эти повороты?